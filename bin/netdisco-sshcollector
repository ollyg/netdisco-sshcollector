#!/usr/bin/perl

# vim: set expandtab tabstop=8 softtabstop=4 shiftwidth=4:

=head1 NAME

netdisco-sshcollector - Collect ARP data for Netdisco from devices
without full SNMP support

=head1 SYNOPSIS

    netdisco-sshcollector [-w workers]

=head1 DESCRIPTION

This program collects ARP data for Netdisco from devices without full SNMP
support. Currently, ARP tables can be retrieved from the following device
classes:

=over 4

=item * C<Netdisco::SSHCollector::Devices::ACE> - Cisco ACE (Application Control Engine) 

=item * C<Netdisco::SSHCollector::Devices::BigIP> - F5 Networks BigIP

=item * C<Netdisco::SSHCollector::Devices::IOS> - Cisco IOS

=back

The collected arp entries are then directly stored in the netdisco database.

=head1 USAGE

=over 4

=item C<-w workers>

Number of parallel processes launched. 

Parameter defaults to 10.

=back

=head1 CONFIGURATION

=over 4

=item C<sshcollector>

Data is collected from the machines specified in this setting. The format is a
list of dictionaries. The keys C<ip>, C<user>, C<password>, and C<devicetype>
are required.  Optionally the C<hostname> key can be used instead of the
C<ip>. For example:

 sshcollector:
   - ip: '192.0.2.1'
     user: oliver
     password: letmein
     devicetype: IOS
   - hostname: 'core-router.example.com'
     user: oliver
     password: letmein
     devicetype: IOS

Devicetype is the final part of the classname to be instantiated to query the
host, e.g. devicetype B<ACE> will be queried using
C<Netdisco::SSHCollector::Devices::ACE>.

If the password is "-", public key authentication will be attempted.

=back

=head1 ADDING DEVICES

Additional device classes can be easily integrated just by adding and
additonal class to the C<Netdisco::SSHCollector::Devices> package.  This class
must implement an C<arpnip($hostname, $ssh)> method which returns an array of
hashrefs in the format

 @result = ({ ip => IPADDR, mac => MACADDR }, ...) 

The parameter C<$ssh> is an active C<Net::OpenSSH> connection to the host.
Depending on the target system, it can be queried using simple methods like

 my @data = $ssh->capture("show whatever")

or automated via Expect - this is mostly useful for non-Linux appliances which
don't support command execution via ssh:

 my ($pty, $pid) = $ssh->open2pty or die "unable to run remote command";
 my $expect = Expect->init($pty);
 my $prompt = qr/#/;
 my ($pos, $error, $match, $before, $after) = $expect->expect(10, -re, $prompt);
 $expect->send("terminal length 0\n");
 # etc...

The returned IP and MAC addresses should be in a format that the respective
B<inetaddr> and B<macaddr> datatypes in PostgreSQL can handle.   

=head1 DEPENDENCIES

=over 4

=item L<App::Netdisco>

=item L<Cache::FileCache>

=item L<Net::OpenSSH>

=item L<Parallel::ForkManager>

=item L<Sys::RunAlone>

=back

=head1 COPYRIGHT AND LICENSE

Copyright (C) 2013 by Christian Ramseyer (ramseyer@netnea.com)
Copyright (C) 2013 by the Netdisco Project

This library is free software; you can redistribute it and/or modify it under
the same terms as Perl itself, either Perl version 5.10.0 or, at your option,
any later version of Perl 5 you may have available.

http://dev.perl.org/licenses/artistic.html

=cut

use warnings;
use strict;

our $home;

BEGIN {
  use FindBin;
  FindBin::again();

  $home = ($ENV{NETDISCO_HOME} || $ENV{HOME});

  # try to find a localenv if one isn't already in place.
  if (!exists $ENV{PERL_LOCAL_LIB_ROOT}) {
      use File::Spec;
      my $localenv = File::Spec->catfile($FindBin::RealBin, 'localenv');
      exec($localenv, $0, @ARGV) if -f $localenv;
      $localenv = File::Spec->catfile($home, 'perl5', 'bin', 'localenv');
      exec($localenv, $0, @ARGV) if -f $localenv;

      die "Sorry, can't find libs required for App::Netdisco.\n"
        if !exists $ENV{PERLBREW_PERL};
  }
}

BEGIN {
  use Path::Class;

  # stuff useful locations into @INC and $PATH
  unshift @INC,
    dir($FindBin::RealBin)->parent->subdir('lib')->stringify,
    dir($FindBin::RealBin, 'lib')->stringify;

  use Config;
  $ENV{PATH} = $FindBin::RealBin . $Config{path_sep} . $ENV{PATH};
}

use App::Netdisco;
use App::Netdisco::Core::Arpnip 'store_arp';
use App::Netdisco::Util::Node 'check_mac';
use Dancer ':script';

use Cache::FileCache;
use Data::Printer;
use Getopt::Long;
use Module::Load ();
use Net::OpenSSH;
use Parallel::ForkManager;
use Sys::RunAlone;

#this may be helpful with SSH issues:
#$Net::OpenSSH::debug = ~0;

my $oworkers = 10;
my $namespace = "netdisco-sshcollector";
my $cache = Cache::FileCache->new({namespace => $namespace});
my %stats;

exit main();

sub main {
    GetOptions( "workers=i" => \$oworkers );
    $cache->clear;

    my @input = @{ setting('sshcollector') };
    my $pm = Parallel::ForkManager->new($oworkers);

    foreach my $host (@input) {
        my $hostlabel = (!defined $host->{hostname} or $host->{hostname} eq "-")
            ? $host->{ip} : $host->{hostname};
        next unless $hostlabel;
        my $pid = $pm->start and next;

        my $ssh = Net::OpenSSH->new(
            $hostlabel,
            user => $host->{user},
            password => $host->{password},
            timeout => 30,
            async => 0,
            master_opts => [
                -o => "StrictHostKeyChecking=no",
                -o => "BatchMode=no"
            ],
        );

        process($hostlabel, $ssh, $host);
        $pm->finish;
    }

    $pm->wait_all_children;
    return 0 unless $cache->get_keys();

    foreach my $host ($cache->get_keys()){
        $stats{host}++;
        my $arpentries = $cache->get($host);
        debug sprintf ' [%s] arpnip - retrieved %s entries from %s',
           scalar @$arpentries, $host;
        store_arpentries($arpentries);
    }

    info sprintf ' [%s] arpnip - processed %s ARP Cache entries',
        $stats{host}, $stats{entry};
    return 0;
}

sub process {
    my ($hostlabel, $ssh, $args) = @_;

    my $class = "Netdisco::SSHCollector::Devices::".$args->{devicetype};
    Module::Load::load $class;

    my $device = $class->new();
    my @arpentries = $device->arpnip($hostlabel, $ssh, $args);

    debug p @arpentries;
    if (@arpentries) {
        $cache->set($hostlabel, \@arpentries)
    }
    else {
        warning "WARNING: no entries received from <$hostlabel>";
    }

}

sub store_arpentries {
    my ($arpentries) = @_;

    foreach my $arpentry ( @$arpentries ) {
        # skip broadcast/vrrp/hsrp and other wierdos
        next unless check_mac( undef, $arpentry->{mac} );

        debug sprintf 'arpnip - stored entry: %s / %s', $arpentry->{mac}, $arpentry->{ip};
        store_arp({ node => $arpentry->{mac}, ip => $arpentry->{ip} });

        $stats{entry}++;
    }
}

__END__

